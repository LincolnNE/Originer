# Client-Side State Ownership

## State Ownership Principles

**Frontend**: Owns UI state, optimistic updates, client-side validation  
**Backend**: Owns authoritative learning state, constraints, progress  
**Synchronization**: Frontend syncs with backend, backend is source of truth

---

## State Ownership Matrix

### Frontend Owns (Client-Side)

#### 1. UI State
**Purpose**: Control what user sees and can do

**Owned By**: Frontend (Zustand stores)

**Examples**:
- Current UI state: `idle`, `ready`, `interacting`, `submitting`, `streaming`
- Button enabled/disabled states
- Input field values
- Loading indicators
- Error messages display

**Why Frontend**: Immediate UI feedback, no network delay

**Sync Strategy**: Optimistic updates, reconcile with backend

---

#### 2. Navigation State
**Purpose**: Control screen navigation

**Owned By**: Frontend (with backend validation)

**Examples**:
- Current screen ID (from URL)
- Available screens list
- Locked screens list
- Navigation button states

**Why Frontend**: Immediate navigation, prevent invalid navigation

**Sync Strategy**: Frontend prevents navigation, backend validates on API calls

---

#### 3. Input State
**Purpose**: User input before submission

**Owned By**: Frontend

**Examples**:
- Answer text (before submit)
- Form field values
- Input validation errors
- Character count

**Why Frontend**: Local only, not persisted until submitted

**Sync Strategy**: No sync needed (local only)

---

#### 4. Client-Tracked Progress
**Purpose**: Approximate progress for immediate UI feedback

**Owned By**: Frontend (optimistic)

**Examples**:
- Time spent on screen (approximate, client-tracked)
- Attempt count (optimistic, before backend confirms)
- Progress percentage (calculated client-side)

**Why Frontend**: Immediate UI updates, better UX

**Sync Strategy**: Optimistic updates, reconcile with backend authoritative values

---

#### 5. Constraint Warnings
**Purpose**: Show warnings before blocking

**Owned By**: Frontend (calculated from backend constraints)

**Examples**:
- "3 attempts remaining"
- "Cooldown: 5 seconds"
- "Rate limit: 2 requests/minute"

**Why Frontend**: Immediate feedback, prevent user frustration

**Sync Strategy**: Calculated from backend constraints, validated on API calls

---

### Backend Owns (Authoritative)

#### 1. Session State
**Purpose**: Learning session state

**Owned By**: Backend

**Examples**:
- Session ID
- Session status: `active`, `paused`, `completed`
- Session metadata (subject, topic, learning objective)
- Session timestamps

**Why Backend**: Authoritative, persists across refreshes

**Sync Strategy**: Frontend loads on mount, syncs periodically

---

#### 2. Screen State
**Purpose**: Screen completion and unlock status

**Owned By**: Backend

**Examples**:
- Screen state: `not_started`, `active`, `completed`, `locked`
- Screen unlock status
- Prerequisites met
- Screen completion timestamp

**Why Backend**: Authoritative, prevents cheating

**Sync Strategy**: Frontend loads on screen mount, validates on navigation

---

#### 3. Authoritative Progress
**Purpose**: Actual learning progress

**Owned By**: Backend

**Examples**:
- Actual attempt count (from storage)
- Mastery score (calculated server-side)
- Concepts mastered
- Time spent (server-tracked, if implemented)

**Why Backend**: Authoritative, prevents manipulation

**Sync Strategy**: Frontend loads on mount, updates after API calls

---

#### 4. Screen Constraints
**Purpose**: Learning constraints and limits

**Owned By**: Backend

**Examples**:
- Rate limits
- Cooldown periods
- Max attempts
- Mastery thresholds
- Prerequisites

**Why Backend**: Authoritative, prevents bypassing constraints

**Sync Strategy**: Frontend loads on screen start, validates on actions

---

#### 5. Instructor Responses
**Purpose**: Instructor feedback content

**Owned By**: Backend (generated)

**Examples**:
- Instructor message content
- Feedback type (guidance, correction, etc.)
- Teaching metadata

**Why Backend**: Generated by AI, authoritative

**Sync Strategy**: Streamed via SSE, stored after completion

---

## State Synchronization Strategy

### On Screen Load

```
1. Frontend: Load screen from URL params
2. Frontend: Initialize optimistic state (UI ready)
3. API Call: POST /api/v1/lessons/start
4. Backend: Returns authoritative screen state
5. Frontend: Reconcile optimistic state with backend response
6. Frontend: Update stores with authoritative values
```

### On User Action

```
1. Frontend: Validate action client-side (constraints, UI state)
2. Frontend: Optimistic update (immediate UI feedback)
3. API Call: POST /api/v1/lessons/[screenId]/submit
4. Backend: Validates and processes
5. Backend: Returns authoritative response
6. Frontend: Reconcile optimistic state with backend response
7. Frontend: Rollback if error, update if success
```

### Periodic Sync (Future)

```
1. Frontend: Poll backend for state updates
2. Backend: Returns current authoritative state
3. Frontend: Compare with local state
4. Frontend: Resolve conflicts (backend wins for learning state)
5. Frontend: Update UI if state changed
```

---

## State Stores (Zustand)

### Store Ownership

#### 1. Session Store
**Owns**: Current session ID, session metadata (optimistic)  
**Syncs With**: Backend session state  
**Source of Truth**: Backend

#### 2. Lesson State Store
**Owns**: Current screen ID, UI state, navigation state  
**Syncs With**: Backend screen state  
**Source of Truth**: Backend (for screen state), Frontend (for UI state)

#### 3. Progress Store
**Owns**: Screen progress (optimistic), session progress  
**Syncs With**: Backend progress  
**Source of Truth**: Backend

#### 4. Constraint Store
**Owns**: Active constraints (from backend), constraint warnings  
**Syncs With**: Backend constraints  
**Source of Truth**: Backend

#### 5. Interaction Mode Store
**Owns**: Current interaction mode, allowed actions  
**Syncs With**: Backend screen type  
**Source of Truth**: Frontend (derived from screen type)

---

## Conflict Resolution

### When Frontend and Backend State Differ

**Rule**: Backend wins for learning state, Frontend wins for UI state

**Examples**:

1. **Progress Mismatch**:
   - Frontend: 3 attempts (optimistic)
   - Backend: 2 attempts (authoritative)
   - Resolution: Update frontend to 2 attempts

2. **Screen Unlock Mismatch**:
   - Frontend: Next screen unlocked (optimistic)
   - Backend: Next screen locked (authoritative)
   - Resolution: Lock screen, show unlock requirements

3. **UI State Mismatch**:
   - Frontend: `streaming` (UI state)
   - Backend: `active` (screen state)
   - Resolution: Keep UI state, sync screen state separately

---

## State Persistence

### Frontend Persistence (localStorage)

**Purpose**: Persist UI state across refreshes

**Stored**:
- Current session ID
- Current screen ID
- Draft answers (optional)

**Not Stored**:
- Progress (load from backend)
- Constraints (load from backend)
- Instructor responses (load from backend)

### Backend Persistence (StorageAdapter)

**Purpose**: Authoritative state persistence

**Stored**:
- Session state
- Screen progress
- Messages
- Learner memory

---

## Summary

**Frontend Owns**:
- UI state (immediate feedback)
- Navigation state (with backend validation)
- Input state (local only)
- Client-tracked progress (optimistic)

**Backend Owns**:
- Session state (authoritative)
- Screen state (authoritative)
- Authoritative progress (authoritative)
- Constraints (authoritative)
- Instructor responses (generated)

**Sync Strategy**: Optimistic updates → API call → Reconcile → Rollback on error

**Conflict Resolution**: Backend wins for learning state, Frontend wins for UI state
